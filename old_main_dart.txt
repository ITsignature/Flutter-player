import 'dart:io' show Platform;
import 'package:flutter/material.dart';
import 'package:app_links/app_links.dart';
import 'package:screen_protector/screen_protector.dart';
import 'package:upgrader/upgrader.dart';
import 'package:version/version.dart';
import 'package:url_launcher/url_launcher.dart';
import 'dev_mode_checker.dart';
import 'player_screen.dart';

final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

const appcastURL = 'https://cdn.itsignaturesolutions.com/android/appcast.xml';
// const forceUpdateUrl = 'https://cdn.itsignaturesolutions.com/download.php';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Upgrader.clearSavedSettings(); // testing convenience
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});
  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  late final AppLinks _appLinks;
  bool _blocked = false;

  // --- Upgrade gating state ---
  bool _upgradeDecisionMade = false;     // Upgrader has decided (true/false) to display
  bool _upgradeWillDisplay = false;      // Upgrader WILL display dialog this session
  Uri? _pendingDeepLink;                 // Deep link queued until decision

  @override
  void initState() {
    super.initState();
    _protectScreens();
    _initDeepLinks();
    _checkDevModeAfterBoot();
  }

  Future<void> _checkDevModeAfterBoot() async {
    bool blocked = false;
    try {
      final result = await DevModeChecker.isDeveloperModeOn()
          .timeout(const Duration(seconds: 2));
      blocked = result;
    } catch (_) {
      blocked = false;
    }
    if (mounted && blocked != _blocked) {
      setState(() => _blocked = blocked);
    }
  }

  Future<void> _protectScreens() async {
    try {
      await ScreenProtector.preventScreenshotOn();
      ScreenProtector.addListener(
        () => debugPrint('ðŸ“¸ iOS screenshot detected'),
        (bool isRecording) => debugPrint('ðŸŽ¥ iOS recording: $isRecording'),
      );
    } catch (_) {}
  }

  Future<void> _initDeepLinks() async {
    _appLinks = AppLinks();

    // Initial deep link (cold start):
    final initial = await _appLinks.getInitialLink();
    if (initial != null) {
      _queueOrHandleDeepLink(initial);
    }

    // Streamed links (warm):
    _appLinks.uriLinkStream.listen(
      (uri) => _queueOrHandleDeepLink(uri),
      onError: (_) {},
    );
  }

  // Only handle the link if either:
  //  - Upgrader has decided NOT to show (decision made && !willDisplay), or
  //  - Weâ€™re already past the upgrade flow.
  void _queueOrHandleDeepLink(Uri uri) {
    if (!_upgradeDecisionMade || _upgradeWillDisplay) {
      _pendingDeepLink = uri; // hold it; process after decision or after update
      return;
    }
    _handleLink(uri);
  }

  void _handleLink(Uri uri) {
    final token = uri.queryParameters['token'];
    if (token != null && token.isNotEmpty) {
      navigatorKey.currentState?.pushReplacement(
        MaterialPageRoute(
          builder: (_) => PlayerScreen(token: token, domain: ''),
        ),
      );
    }
  }

  @override
  void dispose() {
    try {
      ScreenProtector.removeListener();
      ScreenProtector.preventScreenshotOff();
    } catch (_) {}
    super.dispose();
  }

  Version _detectOsVersion() {
    try {
      final raw = Platform.operatingSystemVersion;
      final m = RegExp(r'(\d+)(?:\.(\d+))?(?:\.(\d+))?').firstMatch(raw);
      if (m != null) {
        final major = int.tryParse(m.group(1) ?? '0') ?? 0;
        final minor = int.tryParse(m.group(2) ?? '0') ?? 0;
        final patch = int.tryParse(m.group(3) ?? '0') ?? 0;
        return Version(major, minor, patch);
      }
    } catch (_) {}
    return Version(0, 0, 0);
  }

  // Future<void> _openForceUpdateUrl() async {
  //   final uri = Uri.parse(forceUpdateUrl);
  //   await launchUrl(uri, mode: LaunchMode.externalApplication);
  // }

  @override
  // Widget build(BuildContext context) {
  //   final upgrader = Upgrader(
  //     storeController: UpgraderStoreController(
  //       onAndroid: () => UpgraderAppcastStore(
  //         appcastURL: appcastURL,
  //         osVersion: _detectOsVersion(), // required on ^12.x
  //       ),
  //     ),
  //     debugLogging: true,
  //     //debugDisplayAlways: true, // keep while testing
  //     durationUntilAlertAgain: const Duration(seconds: 2),

  //     // Upgrader tells us if it WILL display a dialog this build.
  //     willDisplayUpgrade: ({
  //       required bool display,
  //       String? installedVersion,
  //       UpgraderVersionInfo? versionInfo,
  //     }) {
  //       _upgradeDecisionMade = true;
  //       _upgradeWillDisplay = display;
  //       debugPrint('willDisplayUpgrade => display=$display, installed=$installedVersion, latest=${versionInfo?.appStoreVersion}');

  //       // If no dialog will be shown and we have a queued deep link, process it now.
  //       if (!display && _pendingDeepLink != null) {
  //         final uri = _pendingDeepLink!;
  //         _pendingDeepLink = null;
  //         WidgetsBinding.instance.addPostFrameCallback((_) => _handleLink(uri));
  //       }
  //     },
  //   );

  //   // IMPORTANT per README: UpgradeAlert belongs BELOW MaterialApp so routing doesnâ€™t suppress it.
  //   // (Their example shows UpgradeAlert as the home widget.) :contentReference[oaicite:1]{index=1}
  //   return MaterialApp(
  //     navigatorKey: navigatorKey,
  //     debugShowCheckedModeBanner: false,
  //     home: UpgradeAlert(
  //       upgrader: upgrader,
  //       showIgnore: false,
  //       showLater: false,
  //       barrierDismissible: false,
  //       shouldPopScope: () => false,
  //       dialogStyle: UpgradeDialogStyle.material,

  //       // Intercept UPDATE NOW â†’ open your download.php and stop default flow.
  //       onUpdate: () {
  //         _openForceUpdateUrl(); // fire-and-forget
  //         return false;          // block default (store) action
  //       },

  //       child: Stack(
  //         children: [
  //           PlayerScreen(token: '', domain: ''),
  //           if (_blocked) const _BlockedOverlay(),
  //         ],
  //       ),
  //     ),
  //   );
  // }

  @override
Widget build(BuildContext context) {
  final upgrader = Upgrader(
    storeController: UpgraderStoreController(
      onAndroid: () => UpgraderAppcastStore(
        appcastURL: appcastURL,
        osVersion: _detectOsVersion(),
      ),
    ),
    debugLogging: true,
    durationUntilAlertAgain: const Duration(seconds: 2),

    // track whether a dialog will show (so you can delay deep links, etc.)
    willDisplayUpgrade: ({
      required bool display,
      String? installedVersion,
      UpgraderVersionInfo? versionInfo,
    }) {
      _upgradeDecisionMade = true;
      _upgradeWillDisplay = display;
      if (!display && _pendingDeepLink != null) {
        final uri = _pendingDeepLink!;
        _pendingDeepLink = null;
        WidgetsBinding.instance.addPostFrameCallback((_) => _handleLink(uri));
      }
    },
  );

  return MaterialApp(
    navigatorKey: navigatorKey,
    debugShowCheckedModeBanner: false,
    home: UpgradeAlert(
      upgrader: upgrader,
      showIgnore: false,
      showLater: false,
      barrierDismissible: false,
      shouldPopScope: () => false,
      dialogStyle: UpgradeDialogStyle.material,

      // ðŸ”‘ Use the URL from your XMLâ€™s <enclosure url="...">
      onUpdate: () {
  final target = upgrader.currentAppStoreListingURL
      ?? upgrader.versionInfo?.appStoreListingURL; // optional fallback
  if (target != null && target.isNotEmpty) {
    final uri = Uri.tryParse(target);
    if (uri != null) {
      launchUrl(uri, mode: LaunchMode.externalApplication);
    }
  }
  return false; // block default behavior
},


      child: Stack(
        children: [
          PlayerScreen(token: '', domain: ''),
          if (_blocked) const _BlockedOverlay(),
        ],
      ),
    ),
  );
}
}

class _BlockedOverlay extends StatelessWidget {
  const _BlockedOverlay();

  @override
  Widget build(BuildContext context) {
    return ColoredBox(
      color: Colors.white,
      child: Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: const [
              Icon(Icons.block, size: 64, color: Colors.red),
              SizedBox(height: 16),
              Text(
                "ðŸš« Developer Mode is enabled",
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Colors.black87),
                textAlign: TextAlign.center,
              ),
              SizedBox(height: 8),
              Text(
                "Please disable it to continue.",
                style: TextStyle(fontSize: 16, color: Colors.black54),
                textAlign: TextAlign.center,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
